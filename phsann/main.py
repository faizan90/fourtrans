'''
@author: Faizan

Dec 30, 2019

1:25:46 PM
'''

from pathos.multiprocessing import ProcessPool

import numpy as np

from ..simultexts.misc import print_sl, print_el, ret_mp_idxs
from ..cyth import (
    get_asymms_sample,
    fill_bi_var_cop_dens,
    )

from .algorithm import PhaseAnnealingAlgorithm as PAA


class PhaseAnnealing(PAA):

    '''
    Phase Annealing

    Description
    -----------
    The phase annealing algorithm to generate 1D series that have
    some given prescribed properties similar to a reference series.

    Usage
    -----
    Call the following methods in the given order. All are required except
    when mentioned otherwise. See their respective documentations for the
    form of inputs. For usage you can also refer to test_phsann.py in the
    test directory.

    1. set_reference_data
    2. set_objective_settings
    3. set_annealing_settings
    4. set_annealing_auto_temperature_settings (optional)
    5. set_misc_settings
    6. prepare
    7. verify
    8. generate_realizations
    9. get_realizations

    Outputs
    -------
    get_realizations returns a list of tuples of all the outputs
    generated by the algorithm.
    '''

    def __init__(self, verbose=True):

        PAA.__init__(self, verbose)

        self._main_alg_reals = None

        self._main_auto_temp_search_ress = None

        self._main_reals_gen_flag = False
        self._main_verify_flag = False
        return

    def _update_ref_at_end(self):

        probs = self._ref_rnk / (self._data_ref_shape[0] + 1.0)

        assert np.all((0 < probs) & (probs < 1)), 'probs out of range!'

        scorrs = np.full(self._sett_obj_lag_steps.size, np.nan)

        asymms_1 = np.full(self._sett_obj_lag_steps.size, np.nan)

        asymms_2 = np.full(self._sett_obj_lag_steps.size, np.nan)

        ecop_dens_arrs = np.full(
            (self._sett_obj_lag_steps.size,
             self._sett_obj_ecop_dens_bins,
             self._sett_obj_ecop_dens_bins),
             np.nan,
             dtype=np.float64)

        for i, lag in enumerate(self._sett_obj_lag_steps):
            rolled_probs = np.roll(probs, lag)

            scorrs[i] = np.corrcoef(probs, rolled_probs)[0, 1]

            asymms_1[i], asymms_2[i] = get_asymms_sample(
                probs, rolled_probs)

            asymms_1[i] = asymms_1[i] / self._get_asymm_1_max(scorrs[i])

            asymms_2[i] = asymms_2[i] / self._get_asymm_2_max(scorrs[i])

            fill_bi_var_cop_dens(
                probs, rolled_probs, ecop_dens_arrs[i, :, :])

        assert np.all(np.isfinite(scorrs)), 'Invalid values in scorrs!'

        assert np.all((scorrs >= -1.0) & (scorrs <= +1.0)), (
            'scorrs out of range!')

        assert np.all(np.isfinite(asymms_1)), 'Invalid values in asymms_1!'

        assert np.all((asymms_1 >= -1.0) & (asymms_1 <= +1.0)), (
            'asymms_1 out of range!')

        assert np.all(np.isfinite(asymms_2)), 'Invalid values in asymms_2!'

        assert np.all((asymms_2 >= -1.0) & (asymms_2 <= +1.0)), (
            'asymms_2 out of range!')

        assert np.all(np.isfinite(ecop_dens_arrs)), (
            'Invalid values in ecop_dens_arrs!')

        self._ref_scorrs = scorrs
        self._ref_asymms_1 = asymms_1
        self._ref_asymms_2 = asymms_2
        self._ref_ecop_dens_arrs = ecop_dens_arrs
        return

    def _auto_temp_search(self):

        if self._vb:
            print_sl()

            print('Generating auto_init_temp realizations...')

            print_el()

        assert self._main_verify_flag, 'Call verify first!'

        self._alg_ann_runn_auto_init_temp_search_flag = True

        self._alg_sim_ann_init_temps = (
            [self._sett_ann_init_temp] * self._sett_ann_auto_init_temp_atpts)

        ann_init_temps = []
        auto_temp_search_ress = []

        reals_gen = (
            (
            (0, self._sett_ann_auto_init_temp_atpts),
            )
            for i in range(self._sett_misc_nreals))

        if self._sett_misc_ncpus > 1:

            mp_pool = ProcessPool(self._sett_misc_ncpus)

            mp_rets = list(
                mp_pool.uimap(self._get_realization_multi, reals_gen))

            mp_pool = None

        else:
            mp_rets = []
            for real_args in reals_gen:
                mp_rets.append(self._get_realization_multi(real_args))

        if self._vb:
            print(
                'Selected the following temperatures with their '
                'corresponding acceptance rates:')

        not_acptd_ct = 0
        for i in range(self._sett_misc_nreals):
            acpt_rates_temps = np.atleast_2d(mp_rets[i])

            auto_temp_search_ress.append(acpt_rates_temps)

            within_range_idxs = (
                (self._sett_ann_auto_init_temp_acpt_bd_lo <=
                 acpt_rates_temps[:, 0]) &
                (self._sett_ann_auto_init_temp_acpt_bd_hi >=
                 acpt_rates_temps[:, 0]))

            if not within_range_idxs.sum():
                acpt_rate = np.nan
                ann_init_temp = np.nan

            else:
                acpt_rates_temps = np.atleast_2d(
                    acpt_rates_temps[within_range_idxs, :])

                best_acpt_rate_idx = np.argmin(
                    (acpt_rates_temps[:, 0] -
                     self._sett_ann_auto_init_temp_trgt_acpt_rate) ** 2)

                acpt_rate, ann_init_temp = acpt_rates_temps[
                    best_acpt_rate_idx, :]

            ann_init_temps.append(ann_init_temp)

            if not (
                self._sett_ann_auto_init_temp_acpt_bd_lo <=
                acpt_rate <=
                self._sett_ann_auto_init_temp_acpt_bd_hi):

                not_acptd_ct += 1

            if self._vb:
                print(f'Realization {i:04d}:', ann_init_temp, acpt_rate)

        if self._vb:
            print('\n')

        if not_acptd_ct:
            raise RuntimeError(
                f'Could not find optimal simulated annealing inital '
                f'temperatures for {not_acptd_ct} out of '
                f'{self._sett_misc_nreals} simulations!')

        self._alg_sim_ann_init_temps = ann_init_temps
        self._main_auto_temp_search_ress = auto_temp_search_ress

        if self._vb:
            print_sl()

            print('Done generating auto_init_temp realizations.')

            print_el()

        self._alg_ann_runn_auto_init_temp_search_flag = False
        return

    def _generate_realizations_regular(self):

        if self._vb:
            print_sl()

            print('Generating regular realizations...')

            print_el()

        assert self._main_verify_flag, 'Call verify first!'

        self._main_alg_reals = []

        mp_idxs = ret_mp_idxs(self._sett_misc_nreals, self._sett_misc_ncpus)

        reals_gen = (
            (
            (mp_idxs[i], mp_idxs[i + 1]),
            )
            for i in range(mp_idxs.size - 1))

        if self._sett_misc_ncpus > 1:

            mp_pool = ProcessPool(self._sett_misc_ncpus)

            mp_rets = list(
                mp_pool.uimap(self._get_realization_multi, reals_gen))

            mp_pool = None

            for i in range(self._sett_misc_ncpus):
                self._main_alg_reals.extend(mp_rets[i])

        else:
            for real_args in reals_gen:
                self._main_alg_reals.extend(
                    self._get_realization_multi(real_args))

        if self._vb:
            print_sl()

            print('Done generating regular realizations.')

            print_el()

        return

    def generate_realizations(self):

        '''Start the phase annealing algorithm'''

        if self._sett_auto_temp_set_flag:
            self._auto_temp_search()

        self._generate_realizations_regular()

        self._update_ref_at_end()

        self._main_reals_gen_flag = True
        return

    def get_realizations(self):

        assert self._main_reals_gen_flag, 'Call generate realizations first!'

        return self._main_alg_reals

    def verify(self):

        PAA._PhaseAnnealingAlgorithm__verify(self)
        assert self._alg_verify_flag, 'Algorithm in an unverified state!'

        self._main_verify_flag = True
        return
